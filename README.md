# Proxmox LLM Controller

Цей репозиторій містить повноцінний приклад інтеграції локальної LLM‑системи з Proxmox VE. Він складається з:

* **docker‑compose.yml** – піднімає Ollama, OpenWebUI та Python‑сервіс для керування Proxmox. Ці контейнери взаємодіють між собою через внутрішню мережу.
* **controller/** – вихідний код Python‑сервісу. Це FastAPI застосунок, що підключається до API Proxmox за допомогою бібліотеки `proxmoxer` та надає прості REST‑ендпоінти для списку вузлів, списку LXC‑контейнерів, створення нових LXC і запуску/зупинки контейнерів.

### Автономна автоматизація публікацій у BlissOS

Каталог [`controller/`](controller/) також містить самодостатній Python‑скрипт
для керування Android‑додатками соціальних мереж усередині BlissOS, що працює в
Hyper‑V. Модуль [`bliss_social_automation.py`](controller/bliss_social_automation.py)
надає як об’єктно‑орієнтований API (`BlissSocialAutomation`), так і CLI для
виконання повного циклу публікації:

* підключення до віртуальної машини через `adb` та перевірка стану пристрою;
* інсталяція, перевстановлення або видалення мобільних клієнтів Facebook,
  Instagram, TikTok, Twitter/X, Reddit, LinkedIn і Threads;
* завантаження файлів у файлову систему BlissOS та формування `share`‑інтентів
  з потрібними MIME‑типами, прапорцями доступу та додатковими extras;
* генерація тексту публікації через OpenAI (`BLISS_LLM_PROVIDER=openai`) або
  локальну модель transformers (`BLISS_LLM_PROVIDER=huggingface`), причому всі
  параметри (модель, temperature, кількість токенів) задаються аргументами CLI
  або змінними середовища;
* запуск і попередній прогрів клієнта, надсилання жестів `input text/tap/swipe`
  та виконання пакетних планів публікацій з JSON‑файлів.

Приклад запуску CLI з Windows‑хоста, де BlissOS проброшено на `127.0.0.1:5555`:

```powershell
python -m controller.bliss_social_automation `
  --connect 127.0.0.1:5555 `
  share instagram `
  --prompt "Опиши яскравий уікендовий похід" `
  --media C:\posts\hike.jpg `
  --remote-dir /sdcard/Download/posts
```

Команда під’єднається до віртуальної машини, завантажить зображення, згенерує
опис через обрану LLM і відправить інтент до Instagram. Скрипт повністю
автономний: достатньо надати ADB‑адресу й параметри LLM через аргументи або
змінні середовища (`OPENAI_API_KEY`, `BLISS_LLM_*`).

## Використання

1. Скопіюйте репозиторій на свій хост Proxmox або будь‑який інший сервер із доступом до Proxmox API.
2. Створіть файл `.env` у корені каталогу та заповніть такі змінні:

   ```env
   PROXMOX_HOST=your-proxmox-host:8006
   PROXMOX_USER=root@pam!WebUI
   # PROXMOX_TOKEN_NAME=WebUI  # не обов'язково, автоматично з PROXMOX_USER
   PROXMOX_TOKEN_VALUE=superSecret
   PROXMOX_VERIFY_SSL=False

   # (необов'язково) BlissOS через ADB
   # BLISS_ADB_ADDRESS=192.168.1.220:5555
   # або окремо:
   # BLISS_ADB_HOST=192.168.1.220
   # BLISS_ADB_PORT=5555
   # BLISS_ADB_SERIAL=RQCT30W45KM
   # BLISS_OPENAPI_PATH=/app/openapi_bliss.json
   # ADB_BINARY=/usr/bin/adb  # adb вже входить до образу, змінюйте лише за потреби
   ```

   > Щоб згенерувати API‑токен у Proxmox, відкрийте *Datacenter* → *Permissions* → *API Tokens*.
   > Якщо в `PROXMOX_USER` вказано `root@pam!WebUI`, частина після `!` автоматично
   > використовується як `PROXMOX_TOKEN_NAME`.

3. Додайте приватний SSH‑ключ, який має доступ до вашого вузла Proxmox:

   * покладіть файл ключа у каталог `keys/pve_id_rsa` (він монтується в контейнер як `/keys/pve_id_rsa`);
   * контейнер під час збірки автоматично створює симлінк `~/.ssh/id_rsa` → `/keys/pve_id_rsa`, тому для ручного підключення достатньо `ssh root@IP` (за бажання можна налаштувати `~/.ssh/config`);
   * `proxmox-controller` читає цей файл автоматично через змінну середовища `PVE_SSH_KEY_PATH`.

4. (Необов'язково) Додайте дефолтні параметри SSH для REST-ендпоінтів:

   * `DEFAULT_SSH_HOST` — адреса SSH-хоста. Якщо не задано, використовується `PVE_SSH_HOST`.
   * `DEFAULT_SSH_USER` — користувач (за замовчуванням `root`). Також успадковує `PVE_SSH_USER`.
   * `DEFAULT_SSH_PORT` — порт SSH (типово `22`).
   * `DEFAULT_SSH_KEY_PATH` або `DEFAULT_SSH_KEY_B64` — шлях до ключа або приватний ключ у base64-рядку.
   * `DEFAULT_SSH_PASSWORD` — пароль, якщо ключ не використовується.
   * `DEFAULT_SSH_STRICT_HOST_KEY` — `true/false`, щоб увімкнути сувору перевірку відбитку хоста.

   Для ендпоінта створення LXC можна також змінити мінімальну довжину пароля,
   який передається в Proxmox. За замовчуванням контролер не приймає паролі
   коротші за пʼять символів, щоби відповідати вимогам API. Якщо у вашій
   інфраструктурі потрібно дозволити коротші значення (наприклад, щоб одразу
   після створення контейнера замінити пароль іншим способом), задайте змінну
   `LXC_PASSWORD_MIN_LENGTH`. Наприклад, `LXC_PASSWORD_MIN_LENGTH=4` дасть змогу
   передати пароль `1023` без помилки валідації.

   Після встановлення цих змінних ендпоінти `/ssh/run`, `/apps/launch` та `/browser/open` можуть викликатися без явного зазначення `host`, `user`, `port` чи автентифікації — значення підставляються автоматично. У конфігурації docker-compose достатньо додати змінні до `.env` поряд із уже наявними `PVE_SSH_*`.

5. Запустіть стек командою:

   ```sh
   docker-compose up -d
   ```

   Після запуску:
   * Ollama API доступний на порті `11434`.
   * OpenWebUI доступна на порті `3000`.
   * Контролер Proxmox доступний на порті `8000` (використовується FastAPI).

  > **Порада.** Якщо отримуєте помилку на кшталт «Connection failed» під час додавання OpenAPI‑специфікації в OpenWebUI,
  > переконайтесь, що використовуєте правильний порт (`http://<host>:8000/openapi.json` або `http://<host>:8000/openapi_bliss.json`).
  > За замовчуванням у `docker-compose.yml` проброшено саме порт `8000`; якщо ви вручну змінили його на інший (наприклад, `18000`),
  > не забудьте використати нове значення і пересвідчитись, що контейнер `proxmox-controller` запущений (`docker ps`).

### Усунення проблем з підключенням OpenWebUI → контролера

Найчастіша причина повідомлення «Connection failed» – OpenWebUI не може дістатись до FastAPI‑сервісу. Перевірте послідовно:

1. **Використовуйте адресу всередині docker-мережі.**
   * Якщо OpenWebUI працює в тому ж docker-compose, вкажіть `http://proxmox-controller:8000/openapi.json` (або `/openapi_bliss.json`).
   * Якщо підключаєтесь іззовні (наприклад, з браузера на хості), використовуйте IP/домен хоста, на якому запущено `docker-compose`.
2. **Переконайтесь, що ендпоінт доступний.**
   ```sh
   docker compose exec open-webui curl -f http://proxmox-controller:8000/openapi.json
   docker compose exec open-webui curl -f http://proxmox-controller:8000/openapi_bliss.json
   ```
   Обидві команди мають повернути JSON. Якщо отримуєте помилку, перегляньте журнали контролера: `docker compose logs proxmox-controller`.
3. **Перевірте налаштування BlissOS.**
   ```sh
   docker compose exec proxmox-controller curl -f http://localhost:8000/openapi_bliss/status | jq
   ```
   Поле `configured` має бути `true`, а `loadable` – `true`. Якщо `configured=false`, додайте до `.env` рядок `BLISS_OPENAPI_PATH=/app/openapi_bliss.json` і перезапустіть стек.
   Якщо `loadable=false` або в логах контролера з'являється повідомлення про неможливість прочитати файл, переконайтесь, що
   файл `openapi_bliss.json` дійсно змонтований у контейнер і має права читання (`chmod 644 openapi_bliss.json`).
   Базовий образ вже містить копію `openapi_bliss.json` у каталозі `/app`, тож достатньо не видалити її або перевизначити
   шлях через `BLISS_OPENAPI_PATH`.
4. **Оновіть довірені походження (за потреби).** Якщо OpenWebUI запускається не з того ж хоста або домену, додайте його в змінну `CORS_ALLOW_ORIGINS` (`http://192.168.1.191:3000,http://localhost:3000`).

Після успішного запиту `curl …/openapi.json` інтерфейс OpenWebUI також має змогу імпортувати специфікацію без помилок.

#### BlissOS API: що ще може спричинити «Connection failed»

Якщо ви додаєте саме BlissOS інструмент і отримуєте помилку з підписом «Connection failed», перевірте додаткові моменти:

1. **Повний шлях до OpenAPI.** Потрібно вказувати повний URL до JSON‑файла (наприклад, `http://192.168.1.191:8000/openapi_bliss.json`). Якщо зазначити лише базову адресу `http://192.168.1.191:8000`, WebUI не зможе завантажити опис.
2. **CORS‑заголовки.** Коли WebUI відкривається з іншого домену/порту, браузер може блокувати запит. Дозвольте походження WebUI через `Access-Control-Allow-Origin` (наприклад, `*` або конкретний домен).
3. **HTTPS проти HTTP.** Якщо WebUI працює по HTTPS, а BlissOS API – по HTTP, браузер заблокує змішаний вміст. Запускайте BlissOS API по HTTPS, використовуйте `localhost`, або відкривайте WebUI по HTTP.
4. **Доступність сервісу.** Перевірте, чи сам BlissOS сервер запущено на вказаній адресі/порті та віддає JSON. Спробуйте завантажити файл специфікації через браузер або `curl`.
5. **Валідність специфікації.** Упевніться, що файл OpenAPI коректний. Перевірте його у Swagger Editor або іншому валідаторі і переконайтесь у наявності обов’язкових полів.

#### Діагностика стану під'єднання BlissOS

Для перевірки стану мережі BlissOS можна виконати `adb shell settings get global connection_state`. Значення `null` у відповідь означає, що система поки не повідомляє про активне мережеве з'єднання — зазвичай таке трапляється, коли інтерфейс ще ініціалізується або Wi‑Fi не налаштований. Дочекайтесь появи значень `connecting`/`connected` і повторно виконайте `/bliss/adb/connect`, щойно мережа стане доступною.

### Налаштування ADB та підключення BlissOS

Перш ніж виконувати команди, увімкніть **Developer options** у BlissOS (7 натискань на номер збірки) і дозвольте **USB debugging**.
Далі:

1. Під'єднайте BlissOS до хоста через USB або мережу (TCP/IP).
2. Перевірте список пристроїв: `adb devices`. У відповідь має зʼявитися запис на кшталт `192.168.0.5:5555    device`.
3. Якщо BlissOS працює у віртуальній машині, відкрийте порт 5555 і підключіться `adb connect <IP>:5555`.

Root‑доступ не потрібен — достатньо увімкненої налагодження по USB. Коли зʼявиться запис `device`, можна переходити до встановлення APK або виконання shell‑команд.

### Встановлення та видалення додатків BlissOS

BlissOS дає змогу інсталювати Android‑додатки через ADB безпосередньо з вашого хоста. Основні сценарії керування APK такі:

* **Встановлення нового APK.** Використовуйте `adb install /шлях/до/Facebook.apk`, щоб додати застосунок на пристрій BlissOS.
* **Перевстановлення без видалення даних.** Додайте ключ `-r`, якщо потрібно оновити застосунок, зберігши кеш і налаштування: `adb install -r /шлях/до/app.apk`.
* **Видалення користувацького застосунку.** Виконайте `adb uninstall com.facebook.katana`, де `com.facebook.katana` — назва пакета програми. Щоб залишити кеш/дані, додайте прапорець `-k`.

Для описаних операцій root‑права не потрібні. Системні ж застосунки, інтегровані в образ BlissOS, таким способом не видаляються — для них знадобляться root‑доступ або модифіковане системне середовище.

### Автоматичний запуск додатків BlissOS

Після інсталяції APK можна керувати запуском застосунків дистанційно через ADB. Основні підходи такі:

* **Прямий виклик Activity Manager.** Команда `adb shell am start -n <package>/<activity>` відкриває конкретну активність. Наприклад, щоб запустити головний екран Facebook, виконайте `adb shell am start -n com.facebook.katana/.MainTabActivity`. Для інших програм потрібно уточнити імʼя пакета (`package_name`) та активності (`activity_name`).
* **Емуляція натискання на іконку через Monkey.** Якщо точну активність встановити складно, скористайтеся інструментом `monkey`: `adb shell monkey -p com.facebook.katana -c android.intent.category.LAUNCHER 1`. Він викликає launch intent пакета й відкриває стандартну стартову активність.
* **Завершення роботи застосунку.** Для зупинки активного процесу використайте `adb shell am force-stop com.facebook.katana`.

Ці методи працюють і для інших популярних клієнтів соцмереж (Instagram `com.instagram.android`, TikTok `com.zhiliaoapp.musically`, Twitter `com.twitter.android`, Reddit `com.reddit.frontpage`, LinkedIn `com.linkedin.android`, Threads `com.instagram.barcelona` тощо). За потреби поєднуйте їх з REST-ендпоінтом `/bliss/adb/command`, передаючи необхідні аргументи (`{"args": ["shell", "am", "start", "-n", "<package>/<activity>"]}`), щоб запускати інтерфейс безпосередньо з OpenWebUI.

### Передача контенту та публікація в BlissOS

Коли потрібно завантажити підготовлений контент (текст, фото, відео) у BlissOS і одразу передати його в конкретний застосунок, скористайтесь двоетапним сценарієм:

1. **Передача файлів на пристрій через `adb push`.**

   ```sh
   adb push localfile.jpg /sdcard/Download/localfile.jpg
   adb push message.txt /sdcard/Download/message.txt
   ```

   Обидві команди копіюють вихідні файли в каталог `/sdcard/Download` на стороні BlissOS. За потреби замініть імена файлів/каталог на власні.

2. **Виклик інтенту `android.intent.action.SEND`, щоб відкрити екран публікації.**

   Для текстових повідомлень:

   ```sh
   adb shell am start -a android.intent.action.SEND \
     -t text/plain \
     -e android.intent.extra.TEXT "Привіт, світ!" \
     -n com.twitter.android/com.twitter.android.PostActivity
   ```

   Для зображень (можна додати підпис):

   ```sh
   adb shell am start -a android.intent.action.SEND \
     -t image/jpeg \
     -e android.intent.extra.TEXT "Опис зображення" \
     -e android.intent.extra.STREAM /sdcard/Download/photo.jpg \
     -n com.instagram.android/com.instagram.share.handleractivity.ShareHandlerActivity
   ```

   * `-a` визначає дію (у прикладі – SEND).
   * `-t` — MIME-тип даних (`text/plain`, `image/*`, `video/*` тощо).
   * `-e android.intent.extra.TEXT` — рядок із підписом/текстом.
   * `-e android.intent.extra.STREAM` — шлях до файлу, якщо передається медіа.
   * `-n` — повне ім'я компонента (`package/activity`) цільового застосунку.

   Назви активностей можуть відрізнятися у різних версіях застосунків; за потреби з'ясуйте актуальні значення через `adb shell dumpsys package <package>` або сторонні довідники.

3. **Завершення публікації.** Якщо після запуску інтенту потрібно підтвердити публікацію, скористайтесь емуляцією натискань або введенням тексту:

   ```sh
   adb shell input tap X Y
   adb shell input text "Ваш%20текст%20тут"
   ```

   Знайдіть координати кнопки у режимі `Pointer Location` в налаштуваннях розробника BlissOS. Пробіли в команді `input text` замініть на `%20` або використовуйте передачу тексту через `android.intent.extra.TEXT`.

Ця ж схема працює для будь-яких соціальних мереж (Facebook, TikTok, Threads тощо): достатньо вказати правильний пакет/активність та MIME-тип. Якщо потрібно автоматизувати сценарій, обгорніть команди у виклик REST-ендпоінтів контролера (`/bliss/adb/command`) із відповідними аргументами.

### Безпекові та обмежувальні аспекти

Автоматизація взаємодії з соціальними мережами через BlissOS та ADB має низку обмежень, пов'язаних із захисними механізмами платформ. Щоб уникнути блокувань і не втратити доступ до облікового запису, врахуйте такі фактори:

* **CAPTCHA/ReCAPTCHA.** Сервіси можуть запитувати верифікацію при підозрілих діях (наприклад, вході з нового браузера чи пристрою). Автоматичне розв'язання CAPTCHA складне й часто суперечить правилам платформи.
* **Двофакторна автентифікація.** 2FA/MFA вимагає підтвердження через SMS, код з додатку або апаратний ключ. Без додаткового ручного втручання повністю автоматизувати вхід не вдасться.
* **Виявлення нетипової поведінки.** Платформи відстежують масове або надто часте публікування та можуть показувати попередження «ми підозрюємо автоматизовану поведінку», тимчасово обмежувати дії або блокувати акаунт.
* **Перевірка цілісності пристрою.** Окремі клієнти перевіряють SafetyNet/Play Integrity і відмовляються працювати на емульованих, рутованих або модифікованих системах.
* **Умови використання.** Більшість соцмереж прямо забороняють несанкціоноване використання ботів. Порушення політик може призвести до блокування облікового запису чи юридичних наслідків.

Практичні поради для зниження ризиків:

1. Виконуйте перший вхід і налаштування вручну, перш ніж переходити до автоматизації.
2. Імітуйте природну поведінку користувача: додавайте затримки, випадкові прокрутки, уникайте миттєвого повторення однакових дій.
3. Плануйте частоту публікацій і взаємодій, щоб не виглядати як масова розсилка.
4. Розгляньте офіційні API, емулятори або фреймворки автоматизації (Tasker, AccessibilityService, Appium) як безпечнішу альтернативу ADB-скриптам.

### Роль LLM у процесі BlissOS

LLM можуть підсилити автоматизацію BlissOS у двох основних площинах:

1. **Генерація контенту.** Модель (наприклад, GPT) створює текстові описи, підписи, хештеги чи сценарії публікацій. Згенерований текст передається на пристрій через ADB — або прямою командою `adb shell input text`, або `am start -e`, щоб наповнити поля форми. Таким чином, BlissOS отримує готовий контент без ручного введення.
2. **Керування UI.** Експериментальні фреймворки на кшталт DroidBot-GPT чи ADB Bot (Qwen+ADB) дозволяють LLM інтерпретувати природномовні інструкції («опублікуй у Instagram це зображення…») та перетворювати їх на послідовність ADB-команд або жестів у UI. Модель аналізує поточний екран (знімки або ієрархію view) і вирішує, які натискання/введення потрібні далі, щоб виконати завдання.

Практично це реалізується скриптом (наприклад, на Python з `uiautomator2` чи Appium), який запитує LLM через API, отримує згенерований контент та план дій, а потім виконує його за допомогою `adb shell input tap`, `adb shell am start` або методів автоматизації UI. Це дає змогу побудувати повністю автономний конвеєр: LLM генерує, планує й одразу публікує матеріали у вибрані застосунки BlissOS.

### Альтернативні підходи

* **Web/API інтерфейси.** Багато соцмереж мають офіційні API для публікації контенту (Instagram Graph API, Facebook Graph API тощо). Вони дозволяють надсилати пости без емулювання UI, однак потребують реєстрації застосунку, OAuth-авторизації та можуть обмежувати кількість запитів або вимагати бізнес-акаунт.
* **Емулятори Android.** Замість реального BlissOS можна запустити Android-емулятор (Android Studio AVD, Genymotion, Bluestacks тощо) і керувати ним через ADB. Емулятор спрощує тестування сценаріїв, встановлення застосунків і автоматизацію дій; деякі конфігурації підтримують Google Play Services, що полегшує роботу з залежними додатками.
* **Tasker / MacroDroid.** Ці Android-додатки дозволяють створювати автоматизації безпосередньо на пристрої. Їхні профілі можна запускати з ADB або передавати дані, після чого Tasker виконує потрібні дії через AccessibilityService чи власний UI-движок.
* **Власний AccessibilityService.** Можна розробити Android-додаток із сервісом доступності, який отримує право читати й взаємодіяти з UI інших застосунків. Це потребує програмування, зате дає гнучкість у натисканнях, заповненні полів і реакції на зміну елементів.
* **Appium, UI Automator тощо.** Фреймворки на кшталт Appium, Espresso або UI Automator дають змогу писати автоматизовані UI-тести, що керують інтерфейсом застосунку. Наприклад, UI Automator знаходить елементи за ID або текстом та симулює кліки чи введення, а Appium дозволяє описувати сценарії на Python/Java/JS, використовуючи AndroidDriver або UIAutomator ([lambdatest.com](https://www.lambdatest.com/)). Це може бути альтернативою ADB-скриптам для складніших сценаріїв.

### Підключення кількох OpenAPI-інструментів в OpenWebUI

OpenWebUI дозволяє одночасно реєструвати кілька інструментів, кожен з яких працює на власному OpenAPI-сервері. Щоб додати їх:

1. Відкрийте **Settings → Tools** у WebUI та натисніть **Add Tool** для кожного сервісу.
2. Вкажіть **повний URL** до OpenAPI-специфікації, включно з файлом JSON, наприклад `http://192.168.1.191:8000/openapi_bliss.json`. Недостатньо вказати лише базову адресу сервера.
3. Повторіть ці кроки для кожного інструменту (`time`, `memory`, `proxmox-controller` тощо). Кожен сервіс має слухати власний порт/адресу і працює незалежно.
4. За потреби комбінуйте інструменти в чаті OpenWebUI — система підтягує лише той OpenAPI, який відповідає на запит.

> 📘 **Скільки інструментів можна підключити?** У документації OpenWebUI наголошено, що всі сервери інструментів працюють незалежно і немає фіксованого обмеження на їхню кількість. Головне — щоб кожен сервіс був доступний за власною адресою/портом і мав валідний OpenAPI-файл (`openapi`, `info`, `paths`, унікальні `operationId`).

OpenWebUI підтримує два режими підключення інструментів:

* **User Tool Server** — браузер користувача звертається до OpenAPI-сервера напряму. Використовуйте для локальних адрес (`http://localhost:8000/openapi.json`).
* **Global Tool Server** — запити йдуть із бекенда OpenWebUI. Корисно, якщо інструмент доступний із мережі контейнерів, але не з робочої станції користувача.

Якщо обираєте локальні адреси (`localhost`), переконайтесь, що браузер має доступ до відповідного порту, або використовуйте User Tool Server. Для віддалених сервісів на окремих хостах зазвичай підходить Global Tool Server.

Нижче наведено мінімальний приклад OpenAPI-опису, який можна використати як шаблон для власних сервісів:

```json
{
  "openapi": "3.0.0",
  "info": {
    "title": "Приклад API",
    "version": "1.0.0"
  },
  "paths": {
    "/items": {
      "get": {
        "summary": "Отримати елементи",
        "responses": {
          "200": {
            "description": "Успіх",
            "content": {
              "application/json": {
                "schema": {
                  "type": "array",
                  "items": {
                    "type": "object"
                  }
                }
              }
            }
          }
        }
      }
    }
  }
}
```

Завантажте власний JSON із подібною структурою та переконайтесь, що OpenWebUI отримує файл без помилок (наприклад, відкривши URL у браузері або через `curl`).

> ℹ️ Додаткові пояснення щодо підключення кількох OpenAPI-серверів і вимог до файлів специфікації дивіться у [FAQ OpenWebUI](https://docs.openwebui.com/openapi-servers/faq/), [документації з інтеграції](https://docs.openwebui.com/openapi-servers/open-webui/) та довідниках із розробки OpenAPI/плагінів ([Dify Blog](https://dify.ai/blog/chatgpt-plugin), [OpenAPI Specification 3.1](https://swagger.io/specification/)).

### Організація описів OpenAPI

OpenWebUI гнучко ставиться до структури OpenAPI-документації, тому ви можете обрати найзручніший спосіб організації файлів:

* **Один сервер – багато функцій.** Якщо сервіс надає декілька тісно пов’язаних можливостей (наприклад, наш контролер Proxmox із
  керуванням LXC, SSH-утилітами та інтеграцією BlissOS), їх можна описати в одному файлі `openapi.json`. Це спрощує імпорт в
  OpenWebUI — достатньо додати один URL.
* **Окремі сервери – чистота і незалежність.** Для відокремлених сервісів зручніше підтримувати власні описи. Ми саме так і
  робимо для BlissOS: додаткові можливості винесені в `openapi_bliss.json`, який підключається окремим інструментом. Якщо ви
  додаєте власні сервіси (наприклад, керування іншою інфраструктурою), створіть для них окремий файл і окремий порт/сервер.

Обидва підходи підтримуються OpenWebUI. Обирайте той, що спрощує оновлення та розгортання ваших інструментів. За потреби можна
поєднати їх: пов’язаний функціонал залишити в загальному `openapi.json`, а незалежні модулі — у власних специфікаціях.

## Виклик API

Використовуйте будь‑який HTTP‑клієнт (curl, Postman, Python `requests`) для взаємодії з контролером:

* **Список вузлів**

  ```sh
  curl http://localhost:8000/nodes
  ```

* **Список LXC на вузлі**

  ```sh
  curl http://localhost:8000/lxc/pve
  ```

* **Створення LXC**

  ```sh
  curl -X POST http://localhost:8000/lxc \
    -H "Content-Type: application/json" \
    -d '{
          "node": "pve",          
          "vmid": 105,
          "ostemplate": "local:vztmpl/debian-12-standard.tar.zst",
          "cores": 2,
          "memory": 2048,
          "hostname": "test-lxc",
          "net0": "name=eth0,bridge=vmbr0,ip=192.168.1.105/24,gw=192.168.1.1",
          "password": "password",
          "features": {"nesting": 1, "keyctl": 1}
      }'
  ```

### BlissOS 16.9.7 через ADB

Для керування BlissOS (Android x86) контролер виконує команди `adb`. Налаштуйте TCP-підключення через змінні середовища:

```env
# host:port TCP-підключення до BlissOS (значення можна одразу додати в .env)
BLISS_ADB_ADDRESS=192.168.1.220:5555
# або окремо
BLISS_ADB_HOST=192.168.1.220
BLISS_ADB_PORT=5555

# Для USB-пристроїв можна задати серійник напряму
BLISS_ADB_SERIAL=RQCT30W45KM

# (необов'язково) власний шлях до OpenAPI або двійки adb
# BLISS_OPENAPI_PATH=/app/openapi_bliss.json
ADB_BINARY=/usr/bin/adb  # adb вже встановлений в образі, змінюйте лише за потреби
```

API-ендпоінти:

* **Перелік пристроїв** – `GET /bliss/adb/devices`
* **Підключення до BlissOS** – `POST /bliss/adb/connect {"host": "192.168.1.220", "port": 5555}`
* **Виконання shell-команд** –

  ```json
  POST /bliss/adb/shell
  {
    "cmd": "input keyevent 26"
  }
  ```

  Для кількох команд використовуйте масив `"commands": ["wm size", "wm density"]`. Параметр `"use_su": true` дозволяє виконувати `su -c`.

* **Будь-які інші adb-операції** – `POST /bliss/adb/command {"args": ["install", "/tmp/app.apk"]}` або

  ```json
  POST /bliss/adb/command
  {
    "command": "shell am start -a android.intent.action.VIEW -d https://example.com"
  }
  ```

* **Роз'єднання** – `POST /bliss/adb/disconnect {"all": true}` або з конкретною адресою.

> Файл [`openapi_bliss.json`](openapi_bliss.json) містить окрему OpenAPI-специфікацію лише для BlissOS/ADB.
> Контролер автоматично підхоплює її з `/app/openapi_bliss.json` (файл уже монтується через `docker-compose.yml`),
> але ви можете вказати інший шлях у змінній `BLISS_OPENAPI_PATH`. Ендпоінт `GET /openapi_bliss.json` дозволить додати BlissOS як
> окремий інструмент в OpenWebUI або іншому клієнті. Основний [`openapi.json`](openapi.json) також містить ці ендпоінти, тож їх
> можна використовувати і без додаткової специфікації. Перевірити стан можна через `GET /openapi_bliss/status`.

#### Як сформулювати запит до ЛЛМ для дії в BlissOS

Щоб агент правильно зрозумів завдання, опиши:

1. **Яку дію треба виконати.** Наприклад, «відкрий панель швидких налаштувань» або «запусти застосунок Firefox».
2. **Де її виконувати.** Зазнач поточний екран, потрібне меню або координати для тапу/свайпу.
3. **Що вважати успіхом.** Поясни, який стан треба перевірити після дії (поява вікна, ввімкнений перемикач тощо).

Приклади запитів:

- «Під'єднайся до BlissOS через ADB, відкрий налаштування Wi-Fi та переконайся, що перемикач увімкнено.»
- «Зроби тап по координатах 960x540, щоб підтвердити діалог, і повідом, чи з'явилось повідомлення про успішне виконання.»
- «Виконай `adb shell am start -n org.mozilla.firefox/.App`, зачекай доки відкриється браузер і надішли скріншот головного екрана.»

Можна формулювати завдання звичайною мовою, але додавай конкретику (ADB-команди, координати, очікувані перевірки), якщо це важливо для точності.

## Архітектура

Локальна LLM, розгорнута через Ollama, може спілкуватися з FastAPI‑контролером і віддавати завдання (наприклад, створити контейнер) у вигляді JSON. Контролер виконує виклики до Proxmox API з допомогою `proxmoxer` й повертає результат у зручному форматі. Такий підхід дозволяє відокремити LLM від прямого root‑доступу на хості, реалізувати фільтрацію та логування, і легко розширювати функціональність.

## LLM агент

У каталозі [`controller/agent_profile`](controller/agent_profile) зібрані готові артефакти для запуску автономного агента:

- `system_prompt.md` — базова інструкція для моделі з описом місії, правил автономності та доступних інструментів.
- `action_recipes.md` — стислий довідник із прикладами запитів до контролера.
- Python‑модуль `agent_profile` експонує метадані через ендпоінт `GET /agent/profile` (JSON містить промпт, довідник та дефолтні параметри інфраструктури).

### Як підключити в OpenWebUI

1. Запустіть стек `docker-compose up -d`.
2. У OpenWebUI відкрийте **Tools → API Specifications** та додайте адресу `http://proxmox-controller:8000/openapi.json`.
3. Створіть новий **Persona** і вставте текст із `controller/agent_profile/system_prompt.md` у поле *System Prompt*.
4. За бажанням додайте `controller/agent_profile/action_recipes.md` як *Knowledge* або вбудуйте у prompt.
5. Після цього модель розумітиме, що має повний доступ до контролера і може виконувати задачі автономно. Додаткову інформацію можна також отримати через `GET http://proxmox-controller:8000/agent/profile`.

### Використання в інших фреймворках

Ендпоінт `/agent/profile` повертає всі необхідні текстові ресурси, тож його можна підвантажувати в будь-який orchestration-пайплайн (OpenAI Assistants, Ollama API, LangChain тощо) і автоматично формувати системне повідомлення для агента.

## Dependency management

Python dependencies for the controller reside in `controller/requirements.txt` and use compatible release specifiers (e.g., `fastapi~=0.111`). After modifying versions, reinstall the environment:

```bash
pip install -r controller/requirements.txt
```

To generate a fully pinned lock file with all transitive dependencies, use `pip-tools`:

```bash
pip install pip-tools
pip-compile controller/requirements.txt --output-file controller/requirements.lock
```
